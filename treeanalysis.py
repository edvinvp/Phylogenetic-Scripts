# @edvin von platen

import json, os
from collections import defaultdict
from collections import Counter
from io import StringIO #Read newick strings
from Bio import Phylo
import matplotlib.pyplot as plt
import numpy as np
from ete3 import Tree

def tree_analysis(json_path, tree_path):
    ## Filename specification:
    # Simulation data from HostTreeGen etc:
    # sim_data/h5/h5.1.pruned.tree , sim_data/real/r.1.pruned.tree , sim_data/h4/h4.1.pruned.tree
    
    # Simulation data in json format from VMCMC parsed DLRS data
    # traces/h5/json/1.json
    
    # Read all guest trees generated by GuestTreeGen
    # key = run number, val = tree string
    GuestTreeGen_trees = defaultdict()
    tree_files = [pos_tree for pos_tree in os.listdir(tree_path) if pos_tree.endswith(".pruned.tree")]
    for index, tr in enumerate(tree_files):
        with open(tree_path + tr) as tree_file:
            idx = int(tr.split('.')[1]) # run number
            no_comment_tree_str = ""
            tree_str = tree_file.read()
            i = 0
            # ete3 can't read the commented newick strings. Remove comments.
            while i < len(tree_str):
                if (tree_str[i] == '['):
                    i += 1
                    while(tree_str[i] != ']'):
                        i += 1
                    i += 1
                if (tree_str[i] != '['):
                    no_comment_tree_str = no_comment_tree_str + tree_str[i]
                    i += 1
            GuestTreeGen_trees[idx] = no_comment_tree_str
        
    # Find and open all available JSON files
    json_files = [pos_json for pos_json in os.listdir(json_path) if pos_json.endswith('.json')]
    # Store trees in Phylo format
    trees = defaultdict(list)
    # Store posterior probabilities for all trees
    probabilities = defaultdict(list)
    # Store number of leafs for all trees
    leaf_count = defaultdict(list)
    # Store number of duplicates for all trees
    duplicates = defaultdict(list)
    # Store number of trees for all dlrs runs
    num_of_trees = defaultdict(list)
    # Read VMCMC tree data into dicts (using VMCMC -p option)
    GuestTree_probabilities = defaultdict() # input to DLRS guest tree
    # tuple data test
    GuestTree_data = defaultdict(lambda: (0.0, 0, 0)) # (prob,leaefcount, duplicates)
    GuestTree_ete_trees = defaultdict()
    ete_trees = defaultdict(list)
    
    RF_distances = defaultdict(list)
    RF_list = []
    print("json files : " + str(len(json_files)))
    print(json_files)
    print(GuestTreeGen_trees.keys())
    for index, js in enumerate(json_files):
        with open(json_path + js) as json_file:
            idx = int(js.split('.')[0]) # run number
            gt_in = Tree(GuestTreeGen_trees[idx], format=1) # GT from GuestTreeGen
            GuestTree_ete_trees[idx] = gt_in
            json_data = json.load(json_file)
            num_of_trees[idx] = len(json_data["Trees"]["Series_0"])
            for i in range(len(json_data["Trees"]["Series_0"])):
                newick = json_data["Trees"]["Series_0"][i]["Newick"]
                handle = StringIO(newick)
                tree = Phylo.read(handle, "newick") # Count leafs with Phylo, RF with ete3
                trees[idx].append(Tree)
                
                prob = json_data["Trees"]["Series_0"][i]["Posterior probability"]
                leafs = tree.count_terminals()
                dups = json_data["Trees"]["Series_0"][i]["Duplicates"]
                probabilities[idx].append(json_data["Trees"]["Series_0"][i]["Posterior probability"])
            
                # Robinson foulds analysis:
                # Calculate RF between the guest tree and all trees in the run.
                gt_out = Tree(newick, format=1)
                ete_trees[idx].append(gt_out)
                rf, max_rf, common_leaves, parts_t1, parts_t2, s1, s2 = gt_in.robinson_foulds(gt_out)
                if prob < 0.01:
                    print("small prob yo: " + str(prob))
                if prob >= 0.01:
                    rf_old = rf
                    rf = rf / max_rf / prob
                    RF_distances[idx].append(rf)
                    RF_list.append(rf)
            
                leaf_count[idx].append(tree.count_terminals())
                duplicates[idx].append(json_data["Trees"]["Series_0"][i]["Duplicates"])
            
                if rf == 0: # It's the DLRS input tree
                    GuestTree_probabilities[idx] = prob
                    GuestTree_data[idx] = (prob, leafs, dups)
                
    ### RF Plot
                    
    plt.hist(RF_list, bins=np.arange(min(RF_list), max(RF_list) + 3, 3))
    plt.xlabel("RF* distance. n=" + str(len(RF_list)) + ".")
    plt.ylabel("Trees")
    plt.show()


    ### Maximum probability tree analysis ###
    
    prob_maxes = [e[0] for e in probabilities.values()]
    plt.hist(prob_maxes, bins=np.arange(min(prob_maxes), max(prob_maxes) + 0.05, 0.05))
    plt.xlabel("Maximum DLRS inferred tree probability. n=" + str(len(prob_maxes)) + ".")
    plt.ylabel("Trees")
    plt.show()
